use std::io;
#[derive(Debug)]
enum Opcode {
    Sum(usize),
    Product(usize),
    Input(usize),
    Output(usize),
    JumpT(usize),
    JumpF(usize),
    Less(usize),
    Equal(usize),
    Halt(usize),
}

fn main() {
    let mut codes = [
        3, 225, 1, 225, 6, 6, 1100, 1, 238, 225, 104, 0, 1101, 37, 34, 224, 101, -71, 224, 224, 4,
        224, 1002, 223, 8, 223, 101, 6, 224, 224, 1, 224, 223, 223, 1002, 113, 50, 224, 1001, 224,
        -2550, 224, 4, 224, 1002, 223, 8, 223, 101, 2, 224, 224, 1, 223, 224, 223, 1101, 13, 50,
        225, 102, 7, 187, 224, 1001, 224, -224, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 5, 224,
        1, 224, 223, 223, 1101, 79, 72, 225, 1101, 42, 42, 225, 1102, 46, 76, 224, 101, -3496, 224,
        224, 4, 224, 102, 8, 223, 223, 101, 5, 224, 224, 1, 223, 224, 223, 1102, 51, 90, 225, 1101,
        11, 91, 225, 1001, 118, 49, 224, 1001, 224, -140, 224, 4, 224, 102, 8, 223, 223, 101, 5,
        224, 224, 1, 224, 223, 223, 2, 191, 87, 224, 1001, 224, -1218, 224, 4, 224, 1002, 223, 8,
        223, 101, 4, 224, 224, 1, 224, 223, 223, 1, 217, 83, 224, 1001, 224, -124, 224, 4, 224,
        1002, 223, 8, 223, 101, 5, 224, 224, 1, 223, 224, 223, 1101, 32, 77, 225, 1101, 29, 80,
        225, 101, 93, 58, 224, 1001, 224, -143, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 4, 224,
        1, 223, 224, 223, 1101, 45, 69, 225, 4, 223, 99, 0, 0, 0, 677, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 1105, 0, 99999, 1105, 227, 247, 1105, 1, 99999, 1005, 227, 99999, 1005, 0, 256, 1105,
        1, 99999, 1106, 227, 99999, 1106, 0, 265, 1105, 1, 99999, 1006, 0, 99999, 1006, 227, 274,
        1105, 1, 99999, 1105, 1, 280, 1105, 1, 99999, 1, 225, 225, 225, 1101, 294, 0, 0, 105, 1, 0,
        1105, 1, 99999, 1106, 0, 300, 1105, 1, 99999, 1, 225, 225, 225, 1101, 314, 0, 0, 106, 0, 0,
        1105, 1, 99999, 7, 226, 226, 224, 102, 2, 223, 223, 1005, 224, 329, 101, 1, 223, 223, 108,
        677, 226, 224, 102, 2, 223, 223, 1005, 224, 344, 1001, 223, 1, 223, 1108, 226, 677, 224,
        102, 2, 223, 223, 1005, 224, 359, 1001, 223, 1, 223, 8, 677, 226, 224, 102, 2, 223, 223,
        1006, 224, 374, 1001, 223, 1, 223, 107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 389,
        101, 1, 223, 223, 1108, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 404, 1001, 223, 1,
        223, 108, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 419, 101, 1, 223, 223, 7, 226, 677,
        224, 1002, 223, 2, 223, 1006, 224, 434, 1001, 223, 1, 223, 107, 226, 677, 224, 102, 2, 223,
        223, 1005, 224, 449, 101, 1, 223, 223, 1108, 677, 677, 224, 1002, 223, 2, 223, 1006, 224,
        464, 101, 1, 223, 223, 7, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 479, 101, 1, 223,
        223, 1007, 677, 677, 224, 1002, 223, 2, 223, 1005, 224, 494, 101, 1, 223, 223, 1008, 226,
        226, 224, 102, 2, 223, 223, 1006, 224, 509, 1001, 223, 1, 223, 107, 677, 677, 224, 102, 2,
        223, 223, 1006, 224, 524, 1001, 223, 1, 223, 8, 226, 226, 224, 1002, 223, 2, 223, 1005,
        224, 539, 1001, 223, 1, 223, 1007, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 554, 1001,
        223, 1, 223, 1007, 226, 226, 224, 1002, 223, 2, 223, 1005, 224, 569, 1001, 223, 1, 223, 8,
        226, 677, 224, 1002, 223, 2, 223, 1006, 224, 584, 101, 1, 223, 223, 108, 226, 226, 224,
        1002, 223, 2, 223, 1006, 224, 599, 101, 1, 223, 223, 1107, 677, 226, 224, 1002, 223, 2,
        223, 1005, 224, 614, 1001, 223, 1, 223, 1107, 226, 677, 224, 102, 2, 223, 223, 1006, 224,
        629, 1001, 223, 1, 223, 1008, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 644, 101, 1, 223,
        223, 1107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 659, 1001, 223, 1, 223, 1008, 677,
        677, 224, 102, 2, 223, 223, 1006, 224, 674, 1001, 223, 1, 223, 4, 223, 99, 226,
    ];
    let mut i = 0;
    loop {
        if i >= codes.len() {
            break;
        }
        let opcode = parse_opcode(codes[i]);

        let params = match opcode.0 {
            Opcode::Halt(_) => (0, 0, 0),
            _ => (
                if opcode.1 == 0 {
                    codes[i + 1] as usize
                } else {
                    i + 1
                },
                if opcode.2 == 0 {
                    codes[i + 2] as usize
                } else {
                    i + 2
                },
                if opcode.3 == 0 {
                    codes[i + 3] as usize
                } else {
                    i + 3
                },
            ),
        };
       // println!("{:?}-{:?}", opcode, params);
        match opcode.0 {
            Opcode::Sum(step) => {
                codes[params.2] = codes[params.0] + codes[params.1];
                i += step;
            }
            Opcode::Product(step) => {
                codes[params.2] = codes[params.0] * codes[params.1];
                i += step;
            }
            Opcode::Input(step) => {
                let mut input = String::new();
                println!("Input:");
                io::stdin()
                    .read_line(&mut input)
                    .expect("Failed to read line");

                let input: isize = match input.trim().parse() {
                    Ok(num) => num,
                    Err(_) => break,
                };
                codes[params.0] = input;
                i += step;
            }
            Opcode::Output(step) => {
                println!("Code: {}", codes[params.0]);
                i += step;
            }
            Opcode::Halt(_) => {
                break;
            }
            Opcode::JumpT(step) => {
                if codes[params.0] != 0 {
                    i = codes[params.1] as usize;
                } else {
                    i += step;
                }
            }
            Opcode::JumpF(step) => {
                if codes[params.0] == 0 {
                    i = codes[params.1] as usize;
                } else {
                    i += step;
                }
            }
            Opcode::Less(step) => {
                codes[params.2] = if codes[params.0] < codes[params.1] {
                    1
                } else {
                    0
                };
                i += step;
            }
            Opcode::Equal(step) => {
                codes[params.2] = if codes[params.0] == codes[params.1] {
                    1
                } else {
                    0
                };
                i += step;
            }
        }
    }
}

fn parse_opcode(opcode: isize) -> (Opcode, usize, usize, usize) {
    let mut s_opcode = opcode.to_string();
    let length = s_opcode.len();
    s_opcode = format!("{}{}", "0".repeat(5 - length), opcode.to_string());
    (
        match s_opcode[3..].parse::<usize>().unwrap() {
            1 => Opcode::Sum(4),
            2 => Opcode::Product(4),
            3 => Opcode::Input(2),
            4 => Opcode::Output(2),
            5 => Opcode::JumpT(3),
            6 => Opcode::JumpF(3),
            7 => Opcode::Less(4),
            8 => Opcode::Equal(4),
            _ => Opcode::Halt(1),
        },
        s_opcode[2..3].parse::<usize>().unwrap(),
        s_opcode[1..2].parse::<usize>().unwrap(),
        s_opcode[0..1].parse::<usize>().unwrap(),
    )
}
